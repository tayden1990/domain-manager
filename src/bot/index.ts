import TelegramBot from 'node-telegram-bot-api';
import { DatabaseManager } from '../database';
import { EmailService } from '../services/emailService';
import { WhoisService } from '../services/whoisService';

export class DomainManagerBot {
  private bot: TelegramBot;
  private db: DatabaseManager;
  private emailService: EmailService;
  private pendingUsers: Map<number, { email?: string; code?: string; step?: string }> = new Map();

  constructor(token: string, db: DatabaseManager, emailService: EmailService) {
    this.bot = new TelegramBot(token, { polling: true });
    this.db = db;
    this.emailService = emailService;
    this.setupHandlers();
  }

  private setupHandlers(): void {
    this.bot.onText(/\/start/, this.handleStart.bind(this));
    this.bot.onText(/\/addomain (.+)/, this.handleAddDomain.bind(this));
    this.bot.onText(/\/mydomains/, this.handleMyDomains.bind(this));
    this.bot.onText(/\/deletedom (\d+)/, this.handleDeleteDomain.bind(this));
    this.bot.on('contact', this.handleContact.bind(this));
    this.bot.on('callback_query', this.handleCallbackQuery.bind(this));
    this.bot.on('message', this.handleMessage.bind(this));
  }

  private async handleStart(msg: TelegramBot.Message): Promise<void> {
    const chatId = msg.chat.id;
    const user = await this.db.getUserByTelegramId(msg.from!.id);

    if (user && user.isVerified) {
      this.showMainMenu(chatId);
    } else {
      this.startSignupFlow(chatId);
    }
  }

  private async startSignupFlow(chatId: number): Promise<void> {
    const keyboard = {
      inline_keyboard: [
        [{ text: 'üöÄ Get Started', callback_data: 'start_signup' }],
        [{ text: '‚ùì Help', callback_data: 'help' }]
      ]
    };

    this.bot.sendMessage(chatId, 
      'üéâ Welcome to Domain Manager Bot!\n\n' +
      'üìä Manage your domains effortlessly:\n' +
      '‚Ä¢ Monitor expiration dates\n' +
      '‚Ä¢ Get renewal reminders\n' +
      '‚Ä¢ Track domain information\n' +
      '‚Ä¢ Secure email verification\n\n' +
      'Click "Get Started" to create your account!',
      { reply_markup: keyboard }
    );
  }

  private async showMainMenu(chatId: number): Promise<void> {
    const keyboard = {
      inline_keyboard: [
        [{ text: 'üåê My Domains', callback_data: 'my_domains' }],
        [{ text: '‚ûï Add Domain', callback_data: 'add_domain' }],
        [{ text: '‚öôÔ∏è Settings', callback_data: 'settings' }]
      ]
    };

    this.bot.sendMessage(chatId, 
      'üéâ Welcome back!\n\n' +
      'What would you like to do?',
      { reply_markup: keyboard }
    );
  }

  private async handleCallbackQuery(query: TelegramBot.CallbackQuery): Promise<void> {
    const chatId = query.message!.chat.id;
    const data = query.data!;
    const userId = query.from.id;

    try {
      switch (data) {
        case 'start_signup':
          this.requestEmail(chatId, userId);
          break;
        case 'my_domains':
          await this.handleMyDomainsCallback(chatId, userId);
          break;
        case 'add_domain':
          this.requestDomainInput(chatId, userId);
          break;
        case 'main_menu':
          this.showMainMenu(chatId);
          break;
        case 'settings':
          this.showSettings(chatId);
          break;
        case 'help':
          this.showHelp(chatId);
          break;
        case 'notifications':
          this.showNotificationSettings(chatId);
          break;
        case 'change_email':
          this.requestEmailChange(chatId, userId);
          break;
        case 'enable_notifications':
          await this.enableNotifications(chatId, userId);
          break;
        case 'disable_notifications':
          await this.disableNotifications(chatId, userId);
          break;
        case 'custom_reminder':
          this.showCustomReminderSettings(chatId);
          break;
        case 'account_info':
          await this.showAccountInfo(chatId, userId);
          break;
        case 'export_domains':
          await this.exportDomains(chatId, userId);
          break;
        case 'reminder_1_day':
          await this.setReminderTime(chatId, userId, 1);
          break;
        case 'reminder_7_days':
          await this.setReminderTime(chatId, userId, 7);
          break;
        case 'reminder_30_days':
          await this.setReminderTime(chatId, userId, 30);
          break;
        default:
          if (data.startsWith('domain_')) {
            const domainId = parseInt(data.split('_')[1]);
            await this.showDomainDetails(chatId, domainId, userId);
          } else if (data.startsWith('delete_')) {
            const domainId = parseInt(data.split('_')[1]);
            await this.confirmDeleteDomain(chatId, domainId, userId);
          } else if (data.startsWith('confirm_delete_')) {
            const domainId = parseInt(data.split('_')[2]);
            await this.deleteDomainById(chatId, domainId, userId);
          } else if (data.startsWith('refresh_')) {
            const domainId = parseInt(data.split('_')[1]);
            await this.refreshDomainInfo(chatId, domainId, userId);
          }
      }

      // Answer callback query with timeout handling
      try {
        await this.bot.answerCallbackQuery(query.id);
      } catch (callbackError: any) {
        if (callbackError.message?.includes('query is too old') || 
            callbackError.message?.includes('query ID is invalid')) {
          console.log('‚ö†Ô∏è Callback query expired, ignoring...');
        } else {
          console.error('Callback query error:', callbackError.message);
        }
      }
    } catch (error: any) {
      console.error('Error handling callback query:', error.message);
      
      // Try to answer the callback query even if there was an error
      try {
        await this.bot.answerCallbackQuery(query.id, {
          text: '‚ùå An error occurred. Please try again.',
          show_alert: true
        });
      } catch (callbackError) {
        // Ignore callback answer errors
        console.log('Could not answer callback query due to timeout');
      }
    }
  }

  private async requestEmail(chatId: number, userId: number): Promise<void> {
    this.pendingUsers.set(userId, { step: 'awaiting_email' });
    
    this.bot.sendMessage(chatId, 
      'üìß Please enter your email address:\n\n' +
      'This will be used for:\n' +
      '‚Ä¢ Account verification\n' +
      '‚Ä¢ Domain expiration alerts\n' +
      '‚Ä¢ Important notifications\n\n' +
      'üí° Just type your email and send it!'
    );
  }

  private async requestDomainInput(chatId: number, userId: number): Promise<void> {
    this.pendingUsers.set(userId, { step: 'awaiting_domain' });
    
    this.bot.sendMessage(chatId, 
      'üåê Please enter the domain you want to add:\n\n' +
      'Examples:\n' +
      '‚Ä¢ example.com\n' +
      '‚Ä¢ mywebsite.org\n' +
      '‚Ä¢ company.net\n\n' +
      'üí° Just type the domain name and send it!'
    );
  }

  private async handleMessage(msg: TelegramBot.Message): Promise<void> {
    if (!msg.text || msg.text.startsWith('/')) return;

    const chatId = msg.chat.id;
    const userId = msg.from!.id;
    const pendingUser = this.pendingUsers.get(userId);

    if (!pendingUser) return;

    switch (pendingUser.step) {
      case 'awaiting_email':
        await this.processEmail(chatId, userId, msg.text);
        break;
      case 'awaiting_verification':
        await this.processVerificationCode(chatId, userId, msg.text);
        break;
      case 'awaiting_domain':
        await this.processDomain(chatId, userId, msg.text);
        break;
      case 'awaiting_new_email':
        await this.processEmailChange(chatId, userId, msg.text);
        break;
    }
  }

  private async processEmail(chatId: number, userId: number, email: string): Promise<void> {
    if (!this.isValidEmail(email)) {
      this.bot.sendMessage(chatId, '‚ùå Please enter a valid email address.');
      return;
    }

    // Update pending user
    const pendingUser = this.pendingUsers.get(userId) || {};
    pendingUser.email = email;
    pendingUser.step = 'awaiting_phone';
    this.pendingUsers.set(userId, pendingUser);

    // Send verification code
    const code = this.emailService.generateVerificationCode();
    const sent = await this.emailService.sendVerificationCode(email, code);

    if (sent) {
      this.db.saveVerificationCode(userId, email, code);
      
      this.bot.sendMessage(chatId, 
        `‚úÖ Verification code sent to ${email}\n\n` +
        'üì± Now please share your phone number for account security:'
      );
      
      // Request phone number
      this.bot.sendMessage(chatId, 
        'Please share your phone number:', {
          reply_markup: {
            keyboard: [[{ text: 'üì± Share Phone Number', request_contact: true }]],
            one_time_keyboard: true,
            resize_keyboard: true
          }
        }
      );
    } else {
      this.bot.sendMessage(chatId, '‚ùå Failed to send verification email. Please try again.');
    }
  }

  private async handleContact(msg: TelegramBot.Message): Promise<void> {
    const chatId = msg.chat.id;
    const phoneNumber = msg.contact?.phone_number;
    const userId = msg.from!.id;

    if (!phoneNumber) {
      this.bot.sendMessage(chatId, '‚ùå Phone number is required.');
      return;
    }

    const pendingUser = this.pendingUsers.get(userId);
    if (!pendingUser || !pendingUser.email) {
      this.bot.sendMessage(chatId, '‚ùå Please start the signup process again with /start');
      return;
    }

    try {
      // Create user account
      this.db.createUser(userId, pendingUser.email, phoneNumber);
      
      // Update step for verification
      pendingUser.step = 'awaiting_verification';
      this.pendingUsers.set(userId, pendingUser);
      
      this.bot.sendMessage(chatId, 
        '‚úÖ Phone number registered!\n\n' +
        'üìß Please check your email and enter the verification code:\n\n' +
        'üí° Just type the 6-character code and send it!',
        { reply_markup: { remove_keyboard: true } }
      );
    } catch (error: any) {
      if (error.message?.includes('UNIQUE constraint failed')) {
        this.bot.sendMessage(chatId, 
          '‚ö†Ô∏è Account already exists. Please enter your verification code:',
          { reply_markup: { remove_keyboard: true } }
        );
        pendingUser.step = 'awaiting_verification';
        this.pendingUsers.set(userId, pendingUser);
      } else {
        this.bot.sendMessage(chatId, 
          '‚ùå Error creating account. Please try again with /start',
          { reply_markup: { remove_keyboard: true } }
        );
      }
    }
  }

  private async processVerificationCode(chatId: number, userId: number, code: string): Promise<void> {
    const isValid = this.db.verifyCode(userId, code.toUpperCase());

    if (isValid) {
      this.db.verifyUser(userId);
      this.pendingUsers.delete(userId);
      
      this.bot.sendMessage(chatId, 
        'üéâ Account verified successfully!\n\n' +
        'You can now manage your domains:'
      );
      
      this.showMainMenu(chatId);
    } else {
      this.bot.sendMessage(chatId, 
        '‚ùå Invalid verification code.\n\n' +
        'Please check your email and try again:'
      );
    }
  }

  private async processDomain(chatId: number, userId: number, domain: string): Promise<void> {
    const user = await this.db.getUserByTelegramId(userId);
    if (!user || !user.isVerified) {
      this.bot.sendMessage(chatId, '‚ùå Please complete account verification first.');
      return;
    }

    const cleanDomain = domain.toLowerCase()
      .replace(/^https?:\/\//, '')
      .replace(/^www\./, '')
      .replace(/\/$/, '');
    
    // Validate domain format
    if (!this.isValidDomain(cleanDomain)) {
      this.bot.sendMessage(chatId, 
        '‚ùå Invalid domain format. Please enter a valid domain like:\n' +
        '‚Ä¢ example.com\n' +
        '‚Ä¢ mysite.ir\n' +
        '‚Ä¢ subdomain.example.org'
      );
      return;
    }

    // Check if domain already exists
    const existingDomains = await this.db.getUserDomains(user.id);
    const domainExists = existingDomains.some(d => d.domain.toLowerCase() === cleanDomain);
    
    if (domainExists) {
      this.bot.sendMessage(chatId, 
        `‚ö†Ô∏è Domain "${cleanDomain}" is already in your list!\n\n` +
        'Use "My Domains" to manage your existing domains.'
      );
      this.pendingUsers.delete(userId);
      setTimeout(() => this.showMainMenu(chatId), 2000);
      return;
    }
    
    this.bot.sendMessage(chatId, `üîç Looking up domain information for ${cleanDomain}...`);

    try {
      const domainInfo = await WhoisService.lookupDomain(cleanDomain);
      await this.db.addDomain(user.id, cleanDomain, domainInfo);

      const expiryText = domainInfo.expirationDate 
        ? domainInfo.expirationDate.toDateString()
        : 'Unknown';

      const statusEmoji = this.getDomainStatusEmoji(domainInfo.expirationDate);

      this.bot.sendMessage(chatId, 
        `‚úÖ Domain added successfully!\n\n` +
        `${statusEmoji} **${cleanDomain}**\n` +
        `üìÖ **Expires:** ${expiryText}\n` +
        `üè¢ **Registrar:** ${domainInfo.registrar || 'Unknown'}\n` +
        `üìä **Status:** ${domainInfo.status || 'Unknown'}\n` +
        `üìù **Registration:** ${domainInfo.registrationDate ? domainInfo.registrationDate.toDateString() : 'Unknown'}\n\n` +
        `üîî You'll receive reminders before expiration!`,
        { parse_mode: 'Markdown' }
      );
      
      this.pendingUsers.delete(userId);
      setTimeout(() => this.showMainMenu(chatId), 3000);
    } catch (error) {
      console.error('Domain lookup error:', error);
      
      // For .ir domains or other TLDs that might not have full WHOIS data
      if (cleanDomain.endsWith('.ir') || cleanDomain.includes('.ir.')) {
        try {
          // Add domain with minimal info for Iranian domains
          const basicDomainInfo = {
            domain: cleanDomain,
            registrationDate: null,
            expirationDate: null,
            lastRenewDate: null,
            registrar: 'Unknown (.ir domain)',
            status: 'Active',
            nameServers: []
          };
          
          await this.db.addDomain(user.id, cleanDomain, basicDomainInfo);
          
          this.bot.sendMessage(chatId, 
            `‚úÖ Iranian domain added successfully!\n\n` +
            `üáÆüá∑ **${cleanDomain}**\n` +
            `üìù **Type:** Iranian (.ir) domain\n` +
            `üìä **Status:** Active\n\n` +
            `‚ÑπÔ∏è Iranian domains may have limited WHOIS information.\n` +
            `You can manually update expiration dates in domain details.`,
            { parse_mode: 'Markdown' }
          );
          
          this.pendingUsers.delete(userId);
          setTimeout(() => this.showMainMenu(chatId), 3000);
        } catch (dbError) {
          this.bot.sendMessage(chatId, '‚ùå Failed to add Iranian domain. Please try again.');
          this.pendingUsers.delete(userId);
        }
      } else {
        this.bot.sendMessage(chatId, 
          `‚ùå Failed to lookup domain information for "${cleanDomain}".\n\n` +
          'This could happen if:\n' +
          '‚Ä¢ Domain doesn\'t exist\n' +
          '‚Ä¢ WHOIS server is unavailable\n' +
          '‚Ä¢ Domain has privacy protection\n\n' +
          'Please try again or contact support.'
        );
        this.pendingUsers.delete(userId);
      }
    }
  }

  private isValidDomain(domain: string): boolean {
    const domainRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\.[a-zA-Z]{2,}$/;
    return domainRegex.test(domain) && domain.length <= 253;
  }

  private async handleMyDomainsCallback(chatId: number, userId: number): Promise<void> {
    const user = await this.db.getUserByTelegramId(userId);
    if (!user || !user.isVerified) {
      this.startSignupFlow(chatId);
      return;
    }

    const domains = await this.db.getUserDomains(user.id);

    if (domains.length === 0) {
      const keyboard = {
        inline_keyboard: [
          [{ text: '‚ûï Add Your First Domain', callback_data: 'add_domain' }],
          [{ text: 'üè† Main Menu', callback_data: 'main_menu' }]
        ]
      };
      
      this.bot.sendMessage(chatId, 'üì≠ You have no domains yet.\n\nStart by adding your first domain to monitor its expiration date and get renewal reminders!', { reply_markup: keyboard });
      return;
    }

    const keyboard = domains.map(domain => {
      const expiryText = domain.expirationDate 
        ? new Date(domain.expirationDate).toLocaleDateString()
        : 'Unknown';
      
      const statusEmoji = this.getDomainStatusEmoji(domain.expirationDate);
      
      return [{
        text: `${statusEmoji} ${domain.domain} - ${expiryText}`,
        callback_data: `domain_${domain.id}`
      }];
    });

    keyboard.push([
      { text: '‚ûï Add Domain', callback_data: 'add_domain' },
      { text: 'üè† Main Menu', callback_data: 'main_menu' }
    ]);

    this.bot.sendMessage(chatId, 
      `üìã Your Domains (${domains.length}):\n\n` +
      'Click on any domain to view details and manage it.',
      { reply_markup: { inline_keyboard: keyboard } }
    );
  }

  private getDomainStatusEmoji(expirationDate: Date | string | null): string {
    if (!expirationDate) return '‚ùì';
    
    const expiry = new Date(expirationDate);
    const now = new Date();
    const daysUntilExpiry = Math.ceil((expiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
    
    if (daysUntilExpiry < 0) return 'üî¥'; // Expired
    if (daysUntilExpiry <= 7) return 'üü†'; // Expires soon
    if (daysUntilExpiry <= 30) return 'üü°'; // Warning
    return 'üü¢'; // Good
  }

  private async showDomainDetails(chatId: number, domainId: number, userId: number): Promise<void> {
    const user = await this.db.getUserByTelegramId(userId);
    if (!user || !user.isVerified) {
      this.startSignupFlow(chatId);
      return;
    }

    const domains = await this.db.getUserDomains(user.id);
    const domain = domains.find(d => d.id === domainId);

    if (!domain) {
      this.bot.sendMessage(chatId, '‚ùå Domain not found.');
      return;
    }

    const statusEmoji = this.getDomainStatusEmoji(domain.expirationDate);
    const expiryText = domain.expirationDate 
      ? new Date(domain.expirationDate).toLocaleDateString()
      : 'Unknown';
    
    const registrationText = domain.registrationDate 
      ? new Date(domain.registrationDate).toLocaleDateString()
      : 'Unknown';

    const daysUntilExpiry = domain.expirationDate 
      ? Math.ceil((new Date(domain.expirationDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24))
      : null;

    let expiryWarning = '';
    if (daysUntilExpiry !== null) {
      if (daysUntilExpiry < 0) {
        expiryWarning = 'üö® **EXPIRED!**\n';
      } else if (daysUntilExpiry <= 7) {
        expiryWarning = `‚ö†Ô∏è **Expires in ${daysUntilExpiry} days!**\n`;
      } else if (daysUntilExpiry <= 30) {
        expiryWarning = `üîî Expires in ${daysUntilExpiry} days\n`;
      }
    }

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üîÑ Refresh Info', callback_data: `refresh_${domainId}` },
          { text: 'üóëÔ∏è Delete', callback_data: `delete_${domainId}` }
        ],
        [{ text: 'üìã Back to My Domains', callback_data: 'my_domains' }],
        [{ text: 'üè† Main Menu', callback_data: 'main_menu' }]
      ]
    };

    this.bot.sendMessage(chatId, 
      `${statusEmoji} **Domain Details**\n\n` +
      `üåê **Domain:** ${domain.domain}\n` +
      `${expiryWarning}` +
      `üìÖ **Expires:** ${expiryText}\n` +
      `üìù **Registered:** ${registrationText}\n` +
      `üè¢ **Registrar:** ${domain.registrar || 'Unknown'}\n` +
      `üìä **Status:** ${domain.status || 'Unknown'}\n` +
      `üîÑ **Last Updated:** ${domain.lastRenewDate ? new Date(domain.lastRenewDate).toLocaleDateString() : 'Unknown'}\n` +
      `üìÖ **Added:** ${new Date(domain.createdAt).toLocaleDateString()}`,
      { 
        parse_mode: 'Markdown',
        reply_markup: keyboard 
      }
    );
  }

  private async confirmDeleteDomain(chatId: number, domainId: number, userId: number): Promise<void> {
    const user = await this.db.getUserByTelegramId(userId);
    if (!user) return;

    const domains = await this.db.getUserDomains(user.id);
    const domain = domains.find(d => d.id === domainId);

    if (!domain) {
      this.bot.sendMessage(chatId, '‚ùå Domain not found.');
      return;
    }

    const keyboard = {
      inline_keyboard: [
        [
          { text: '‚úÖ Yes, Delete', callback_data: `confirm_delete_${domainId}` },
          { text: '‚ùå Cancel', callback_data: `domain_${domainId}` }
        ]
      ]
    };

    this.bot.sendMessage(chatId, 
      `‚ö†Ô∏è **Confirm Deletion**\n\n` +
      `Are you sure you want to delete:\n` +
      `üåê **${domain.domain}**\n\n` +
      `This action cannot be undone.`,
      { 
        parse_mode: 'Markdown',
        reply_markup: keyboard 
      }
    );
  }

  private async deleteDomainById(chatId: number, domainId: number, userId: number): Promise<void> {
    const user = await this.db.getUserByTelegramId(userId);
    if (!user) return;

    try {
      await this.db.deleteDomain(user.id, domainId);
      this.bot.sendMessage(chatId, 
        '‚úÖ **Domain deleted successfully!**\n\n' +
        'The domain has been removed from your monitoring list.',
        { parse_mode: 'Markdown' }
      );
      
      setTimeout(() => this.handleMyDomainsCallback(chatId, userId), 1500);
    } catch (error) {
      this.bot.sendMessage(chatId, '‚ùå Failed to delete domain. Please try again.');
    }
  }

  private async showSettings(chatId: number): Promise<void> {
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üîî Notifications', callback_data: 'notifications' },
          { text: 'üìß Change Email', callback_data: 'change_email' }
        ],
        [
          { text: 'üë§ Account Info', callback_data: 'account_info' },
          { text: 'üìã Export Domains', callback_data: 'export_domains' }
        ],
        [{ text: 'üè† Main Menu', callback_data: 'main_menu' }]
      ]
    };

    this.bot.sendMessage(chatId, 
      '‚öôÔ∏è **Settings**\n\n' +
      'Configure your Domain Manager Bot preferences:',
      { 
        parse_mode: 'Markdown',
        reply_markup: keyboard 
      }
    );
  }

  private async showHelp(chatId: number): Promise<void> {
    const keyboard = {
      inline_keyboard: [
        [{ text: 'üöÄ Get Started', callback_data: 'start_signup' }],
        [{ text: 'üè† Main Menu', callback_data: 'main_menu' }]
      ]
    };

    this.bot.sendMessage(chatId, 
      '‚ùì Help & Information\n\n' +
      'üéØ What this bot does:\n' +
      '‚Ä¢ Monitor domain expiration dates\n' +
      '‚Ä¢ Send renewal reminders\n' +
      '‚Ä¢ Track domain registration info\n' +
      '‚Ä¢ Secure account with email + phone\n\n' +
      'üîß Commands:\n' +
      '‚Ä¢ Just use the buttons below!\n' +
      '‚Ä¢ Type domain names directly when asked\n' +
      '‚Ä¢ Follow the guided setup process\n\n' +
      'üìß Need support? Contact your domain administrator.',
      { reply_markup: keyboard }
    );
  }

  private async showNotificationSettings(chatId: number): Promise<void> {
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üîî Enable All', callback_data: 'enable_notifications' },
          { text: 'üîï Disable All', callback_data: 'disable_notifications' }
        ],
        [{ text: '‚è∞ Custom Reminders', callback_data: 'custom_reminder' }],
        [
          { text: 'üîô Back to Settings', callback_data: 'settings' },
          { text: 'üè† Main Menu', callback_data: 'main_menu' }
        ]
      ]
    };

    this.bot.sendMessage(chatId, 
      'üîî **Notification Settings**\n\n' +
      'üìÖ **Current Features:**\n' +
      '‚Ä¢ Domain expiration reminders\n' +
      '‚Ä¢ Renewal alerts (30, 7, 1 days before)\n' +
      '‚Ä¢ System notifications\n' +
      '‚Ä¢ Email notifications\n\n' +
      'Choose your preference:',
      { 
        parse_mode: 'Markdown',
        reply_markup: keyboard 
      }
    );
  }

  private async enableNotifications(chatId: number, userId: number): Promise<void> {
    // In a real implementation, you'd save this to database
    this.bot.sendMessage(chatId, 
      '‚úÖ **Notifications Enabled**\n\n' +
      'You will receive:\n' +
      '‚Ä¢ Domain expiration reminders\n' +
      '‚Ä¢ Renewal alerts\n' +
      '‚Ä¢ System notifications\n\n' +
      'You can change this anytime in settings.',
      { parse_mode: 'Markdown' }
    );
    
    setTimeout(() => this.showNotificationSettings(chatId), 2000);
  }

  private async disableNotifications(chatId: number, userId: number): Promise<void> {
    // In a real implementation, you'd save this to database
    this.bot.sendMessage(chatId, 
      'üîï **Notifications Disabled**\n\n' +
      'You will no longer receive:\n' +
      '‚Ä¢ Domain expiration reminders\n' +
      '‚Ä¢ Renewal alerts\n' +
      '‚Ä¢ System notifications\n\n' +
      '‚ö†Ô∏è **Important:** You may miss important domain renewals!\n\n' +
      'You can re-enable anytime in settings.',
      { parse_mode: 'Markdown' }
    );
    
    setTimeout(() => this.showNotificationSettings(chatId), 2000);
  }

  private showCustomReminderSettings(chatId: number): void {
    const keyboard = {
      inline_keyboard: [
        [
          { text: '1Ô∏è‚É£ 1 Day Before', callback_data: 'reminder_1_day' },
          { text: '7Ô∏è‚É£ 7 Days Before', callback_data: 'reminder_7_days' }
        ],
        [{ text: '3Ô∏è‚É£0Ô∏è‚É£ 30 Days Before', callback_data: 'reminder_30_days' }],
        [
          { text: 'üîô Back to Notifications', callback_data: 'notifications' },
          { text: 'üè† Main Menu', callback_data: 'main_menu' }
        ]
      ]
    };

    this.bot.sendMessage(chatId, 
      '‚è∞ **Custom Reminder Settings**\n\n' +
      'Choose when you want to receive domain expiration reminders:\n\n' +
      'üîî **Current:** Every 3 days when domain expires within 30 days\n\n' +
      'Select your preferred reminder schedule:',
      { 
        parse_mode: 'Markdown',
        reply_markup: keyboard 
      }
    );
  }

  private async setReminderTime(chatId: number, userId: number, days: number): Promise<void> {
    // In a real implementation, you'd save this to database
    this.bot.sendMessage(chatId, 
      `‚úÖ **Reminder Set**\n\n` +
      `üîî You will receive reminders **${days} day${days > 1 ? 's' : ''} before** domain expiration.\n\n` +
      `This setting has been saved to your account.`,
      { parse_mode: 'Markdown' }
    );
    
    setTimeout(() => this.showCustomReminderSettings(chatId), 2000);
  }

  private async showAccountInfo(chatId: number, userId: number): Promise<void> {
    const user = await this.db.getUserByTelegramId(userId);
    
    if (!user || !user.isVerified) {
      this.startSignupFlow(chatId);
      return;
    }

    const domains = await this.db.getUserDomains(user.id);
    const expiringDomains = domains.filter(domain => {
      if (!domain.expirationDate) return false;
      const daysUntilExpiry = Math.ceil((new Date(domain.expirationDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24));
      return daysUntilExpiry <= 30 && daysUntilExpiry > 0;
    });

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üìß Change Email', callback_data: 'change_email' },
          { text: 'üîî Notifications', callback_data: 'notifications' }
        ],
        [
          { text: 'üîô Back to Settings', callback_data: 'settings' },
          { text: 'üè† Main Menu', callback_data: 'main_menu' }
        ]
      ]
    };

    this.bot.sendMessage(chatId, 
      `üë§ **Account Information**\n\n` +
      `üìß **Email:** ${user.email}\n` +
      `üì± **Phone:** ${user.phoneNumber}\n` +
      `üìÖ **Member Since:** ${new Date(user.createdAt).toLocaleDateString()}\n` +
      `‚úÖ **Status:** Verified\n\n` +
      `üìä **Domain Statistics:**\n` +
      `‚Ä¢ Total Domains: ${domains.length}\n` +
      `‚Ä¢ Expiring Soon: ${expiringDomains.length}\n\n` +
      `üÜî **User ID:** ${user.id}`,
      { 
        parse_mode: 'Markdown',
        reply_markup: keyboard 
      }
    );
  }

  private async exportDomains(chatId: number, userId: number): Promise<void> {
    const user = await this.db.getUserByTelegramId(userId);
    
    if (!user || !user.isVerified) {
      this.startSignupFlow(chatId);
      return;
    }

    const domains = await this.db.getUserDomains(user.id);

    if (domains.length === 0) {
      this.bot.sendMessage(chatId, 
        'üì≠ **No Domains to Export**\n\n' +
        'You don\'t have any domains yet. Add some domains first!',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    let exportText = `üìã **Domain Export** - ${new Date().toLocaleDateString()}\n\n`;
    exportText += `üë§ **Account:** ${user.email}\n`;
    exportText += `üìä **Total Domains:** ${domains.length}\n\n`;
    exportText += `üåê **Domain List:**\n\n`;

    domains.forEach((domain, index) => {
      const expiryText = domain.expirationDate 
        ? new Date(domain.expirationDate).toLocaleDateString()
        : 'Unknown';
      
      const statusEmoji = this.getDomainStatusEmoji(domain.expirationDate);
      
      exportText += `${index + 1}. ${statusEmoji} **${domain.domain}**\n`;
      exportText += `   üìÖ Expires: ${expiryText}\n`;
      exportText += `   üè¢ Registrar: ${domain.registrar || 'Unknown'}\n`;
      exportText += `   üìù Added: ${new Date(domain.createdAt).toLocaleDateString()}\n\n`;
    });

    exportText += `üìÑ **Export completed at:** ${new Date().toLocaleString()}\n`;
    exportText += `ü§ñ **Generated by:** Domain Manager Bot`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üîô Back to Settings', callback_data: 'settings' },
          { text: 'üè† Main Menu', callback_data: 'main_menu' }
        ]
      ]
    };

    this.bot.sendMessage(chatId, exportText, { 
      parse_mode: 'Markdown',
      reply_markup: keyboard 
    });
  }

  private async refreshDomainInfo(chatId: number, domainId: number, userId: number): Promise<void> {
    const user = await this.db.getUserByTelegramId(userId);
    if (!user) return;

    const domains = await this.db.getUserDomains(user.id);
    const domain = domains.find(d => d.id === domainId);

    if (!domain) {
      this.bot.sendMessage(chatId, '‚ùå Domain not found.');
      return;
    }

    this.bot.sendMessage(chatId, `üîÑ Refreshing information for ${domain.domain}...`);

    try {
      const domainInfo = await WhoisService.lookupDomain(domain.domain);
      
      // Update domain in database (you'd need to add this method to DatabaseManager)
      // await this.db.updateDomain(domainId, domainInfo);
      
      this.bot.sendMessage(chatId, 
        `‚úÖ **Domain Updated**\n\n` +
        `Information for ${domain.domain} has been refreshed!`,
        { parse_mode: 'Markdown' }
      );
      
      setTimeout(() => this.showDomainDetails(chatId, domainId, userId), 1500);
    } catch (error) {
      this.bot.sendMessage(chatId, 
        `‚ùå **Refresh Failed**\n\n` +
        `Could not update information for ${domain.domain}. Please try again later.`,
        { parse_mode: 'Markdown' }
      );
    }
  }

  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  private async handleAddDomain(msg: TelegramBot.Message, match: RegExpExecArray | null): Promise<void> {
    const chatId = msg.chat.id;
    this.bot.sendMessage(chatId, 'Please use the "Add Domain" button in the main menu for better experience!');
    this.showMainMenu(chatId);
  }

  private async handleMyDomains(msg: TelegramBot.Message): Promise<void> {
    const chatId = msg.chat.id;
    const userId = msg.from!.id;
    await this.handleMyDomainsCallback(chatId, userId);
  }

  private async handleDeleteDomain(msg: TelegramBot.Message, match: RegExpExecArray | null): Promise<void> {
    const chatId = msg.chat.id;
    const domainId = parseInt(match![1]);
    const userId = msg.from!.id;

    const user = await this.db.getUserByTelegramId(userId);
    if (!user || !user.isVerified) {
      this.startSignupFlow(chatId);
      return;
    }

    try {
      await this.db.deleteDomain(user.id, domainId);
      this.bot.sendMessage(chatId, '‚úÖ Domain deleted successfully!');
    } catch (error) {
      this.bot.sendMessage(chatId, '‚ùå Failed to delete domain.');
    }
  }

  private async requestEmailChange(chatId: number, userId: number): Promise<void> {
    this.pendingUsers.set(userId, { step: 'awaiting_new_email' });
    
    this.bot.sendMessage(chatId, 
      'üìß Please enter your new email address:\n\n' +
      'A verification code will be sent to confirm the change.\n\n' +
      'üí° Just type your new email and send it!'
    );
  }

  private async processEmailChange(chatId: number, userId: number, email: string): Promise<void> {
    if (!this.isValidEmail(email)) {
      this.bot.sendMessage(chatId, '‚ùå Please enter a valid email address.');
      return;
    }

    const code = this.emailService.generateVerificationCode();
    const sent = await this.emailService.sendVerificationCode(email, code);

    if (sent) {
      this.db.saveVerificationCode(userId, email, code);
      
      const pendingUser = this.pendingUsers.get(userId) || {};
      pendingUser.email = email;
      pendingUser.step = 'awaiting_email_verification';
      this.pendingUsers.set(userId, pendingUser);
      
      this.bot.sendMessage(chatId, 
        `‚úÖ Verification code sent to ${email}\n\n` +
        'Please enter the verification code to confirm the email change:'
      );
    } else {
      this.bot.sendMessage(chatId, '‚ùå Failed to send verification email. Please try again.');
    }
  }
}
